import random
# UNFAIR DICE TEMPLATE: REPLACE THIS LINE WITH YOUR FILE HEADER


def biased_rolls(prob_list, s, n):
    """ Simulate n rolls of a biased m-sided die and return
    a list containing the results.

    Arguments:
        prob_list: a list of the probabilities of rolling the
                   number on each side of the m-sided die. The list
                   will always have the length m (m >= 2), where m is
                   the number of sides numbered 1 to m. Therefore,
                   for example, the probability stored at index 0 in
                   the list is the probability of rolling a 1 on
                   the m-sided die.
        s: the seed to use when initializing the PRNG
        n: the number of rolls to return

    Return:
        rolls: a list (of length n) containing each of the n rolls of the
               biased die, in the order they were generated.
    """

    random.seed(s)
    dice_side_num = dice_side(prob_list)
    rolls = []

    for i in range(n):
        probability = random.random()
        count = 0 # keeps track of the sum of  probabilities.
        count_2 = 0 # keeps track of the sum of probabilities +1
        sum = 1
        #checks for base case if 0 <=x < prob_list[0]
        if probability <= prob_list[0] and probability > 0:
            rolls.append(dice_side_num[0])
        count += prob_list[0]
        #each iteration checks for if count <= probablity < count_2.
        try:
            for x in range(len(prob_list) - 1):
                count_2 = count + prob_list[x + 1]
                if probability > count and probability < count_2:
                    rolls.append(dice_side_num[x + 1])
                count = count_2
        #except statement is there just in case the program get index out of range error
        except:
            pass

    # return the resulting rolls
    return rolls


def dice_side(prob_list):
    """ Description: get a list of number of Dice sides.
                     Since this list have same indexes and length as prob_list,
                     I can use this list with prob_list to map a probablitiy
                     to a side number.
        argument: the list of probabilities. Ex.[1/4,1/12...etc]
        returns: a list of from [1,2,3...m]; all the number of side of the dice.
                 """
    num = 1
    num_list= []

    for i in range(len(prob_list)):
        num_list.append(num)
        num +=1
    return num_list

def draw_histogram(m, rolls, width):
    """ Draws a frequency histogram of the rolls of an m-sided die
    mapped to a fixed width.

    Arguments: 
        m (int): the number of sides on the die
        rolls (list): the list of rolls generated by the biased die
        width (int): the fixed width of the histogram, in characters
                     (this is the length of the longest bar in the 
                     histogram, to maximize space in the chart)

    Returns:
        None (but prints the histogram to standard output)
    """

    #the greatest frequency of an element of the list. Needed to calculate the ratio for histogram.
    greatest_frequency = most_frequency(rolls)

    #https://www.geeksforgeeks.org/python-find-most-frequent-element-in-a-list/

    #arange list in a ascending order
    rolls.sort()
    rolls_no_duplicate = remove_duplicate(rolls)

    #prints
    draw(rolls, m, width, greatest_frequency)
    # this function should print to standard output
    # you should not return anything!

#this is function returns the side with the highest frequency. It is needed for scaling the Histogram
def most_frequency(rolls):


    frequency = 0
    for i in rolls:
        current_frequency = rolls.count(i)
        if current_frequency > frequency:
            frequency = current_frequency
    return frequency

#return the hashtag
def draw(rolls,m, width, greatest_frequency):
    m_string = str(m)
    print('Frequency Histogram: ' + m_string + '-sided Die')
    for i in range(m):
        count = rolls.count(i + 1)
        ratio = (width / greatest_frequency)  # 8.33333 *
        ratio_X_count = round(ratio * count)

        dash = width - (ratio_X_count)
        dahs_2 = width - count
        num = str(i + 1)
        if width != greatest_frequency:
            print(num + '.' + '#' * (ratio_X_count) + '-' * dash, ratio_X_count)
        else:
            print(num + '.' + '#' * count + '-' * dahs_2, count)



def remove_duplicate(rolls):
    roll_no_duplicate = []
    for i in rolls:
        if i not in roll_no_duplicate:
            roll_no_duplicate.append(i)
    return roll_no_duplicate

if __name__ == "__main__":
    # Any code indented under this line will only be run
    # when the program is called directly from the terminal
    # using "python3 unfairDice.py". This can be useful for
    # testing your implementations.
    rolls = biased_rolls([1/3,1/3,1/3],(2**32)-1,1000)

    draw_histogram(3, rolls, 10)

#[1/12,1/4,1/3,1/12,1/12,1/6]
#[1/4,1/6,1/12,1/12,1/4,1/6]
#[1/3,1/3,1/3]